-- Agda definition of C-- abstract syntax trees
-- and Haskell bindings to the ones generated by the parser.

module AST where

open import Library

{-# FOREIGN GHC import qualified Data.Text #-}
{-# FOREIGN GHC import CPP.Abs #-}
{-# FOREIGN GHC import CPP.Print #-}

data Id : Set where
  mkId : List Char → Id

{-# COMPILE GHC Id = data Id (Id) #-}

data Type : Set where
  bool int double void : Type

{-# COMPILE GHC Type = data Type
  ( Type_bool
  | Type_int
  | Type_double
  | Type_void
  ) #-}

data Exp : Set where
  eTrue     : Exp
  eFalse    : Exp
  eInt      : (i : ℤ)                  → Exp
  eDouble   : (d : Float)              → Exp
  eId       : (x : Id)                 → Exp
  eApp      : (x : Id) (es : List Exp) → Exp
  ePostIncr : (x : Id)                 → Exp
  ePostDecr : (x : Id)                 → Exp
  ePreIncr  : (x : Id)                 → Exp
  ePreDecr  : (x : Id)                 → Exp
  eTimes    : (e e' : Exp)             → Exp
  eDiv      : (e e' : Exp)             → Exp
  ePlus     : (e e' : Exp)             → Exp
  eMinus    : (e e' : Exp)             → Exp
  eLt       : (e e' : Exp)             → Exp
  eGt       : (e e' : Exp)             → Exp
  eLtEq     : (e e' : Exp)             → Exp
  eGtEq     : (e e' : Exp)             → Exp
  eEq       : (e e' : Exp)             → Exp
  eNEq      : (e e' : Exp)             → Exp
  eAnd      : (e e' : Exp)             → Exp
  eOr       : (e e' : Exp)             → Exp
  eAss      : (x : Id) (e : Exp)       → Exp

{-# COMPILE GHC Exp = data Exp
  ( ETrue
  | EFalse
  | EInt
  | EDouble
  | EId
  | EApp
  | EPostIncr
  | EPostDecr
  | EPreIncr
  | EPreDecr
  | ETimes
  | EDiv
  | EPlus
  | EMinus
  | ELt
  | EGt
  | ELtEq
  | EGtEq
  | EEq
  | ENEq
  | EAnd
  | EOr
  | EAss
  ) #-}

data Stm : Set where
  sExp    : (e : Exp)                     → Stm
  sDecls  : (t : Type) (xs : List Id)     → Stm
  sInit   : (t : Type) (x : Id) (e : Exp) → Stm
  sReturn : (e : Exp)                     → Stm
  sWhile  : (e : Exp) (s : Stm)           → Stm
  sBlock  : (ss : List Stm)               → Stm
  sIfElse : (e : Exp) (s s' : Stm)        → Stm

{-# COMPILE GHC Stm = data Stm
  ( SExp
  | SDecls
  | SInit
  | SReturn
  | SWhile
  | SBlock
  | SIfElse
  ) #-}

data Arg : Set where
  aDecl : (t : Type) (x : Id) → Arg

{-# COMPILE GHC Arg = data Arg (ADecl) #-}

data Def : Set where
  dFun : (t : Type) (x : Id) (as : List Arg) (ss : List Stm) → Def

{-# COMPILE GHC Def = data Def (DFun) #-}

data Program : Set where
  pDefs : (ds : List Def) → Program

{-# COMPILE GHC Program = data Program (PDefs) #-}

-- Pretty printer

printId  : Id → String
printId (mkId s) = String.fromList s

postulate
  printType    : Type    → String
  printExp     : Exp     → String
  printStm     : Stm     → String
  printArg     : Arg     → String
  printDef     : Def     → String
  printProgram : Program → String

{-# COMPILE GHC printType    = \ t -> Data.Text.pack (printTree (t :: Type)) #-}
{-# COMPILE GHC printExp     = \ e -> Data.Text.pack (printTree (e :: Exp))  #-}
{-# COMPILE GHC printStm     = \ s -> Data.Text.pack (printTree (s :: Stm))  #-}
{-# COMPILE GHC printArg     = \ a -> Data.Text.pack (printTree (a :: Arg))  #-}
{-# COMPILE GHC printDef     = \ d -> Data.Text.pack (printTree (d :: Def))  #-}
{-# COMPILE GHC printProgram = \ p -> Data.Text.pack (printTree (p :: Program)) #-}
